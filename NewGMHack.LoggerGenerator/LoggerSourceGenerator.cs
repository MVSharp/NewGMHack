using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace NewGMHack.LoggerGenerator
{
    [Generator]
    public class LoggerSourceGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            // Register a syntax receiver that will be created for each compilation
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (!(context.SyntaxReceiver is SyntaxReceiver receiver))
                return;

            // Get the compilation
            var compilation = context.Compilation;

            // Find the ILogger symbol from Microsoft.Extensions.Logging
            var iLoggerSymbol = compilation.GetTypeByMetadataName("Microsoft.Extensions.Logging.ILogger");
            if (iLoggerSymbol == null)
                return;

            // Generate source for each partial class
            foreach (var partialClass in receiver.CandidateClasses)
            {
                // Get the semantic model for this class
                var semanticModel = compilation.GetSemanticModel(partialClass.SyntaxTree);
                var declaredSymbol = semanticModel.GetDeclaredSymbol(partialClass);

                if (declaredSymbol == null)
                    continue;

                var className = partialClass.Identifier.ValueText;
                var namespaceName = GetNamespace(partialClass);
                var containingNamespace = declaredSymbol.ContainingNamespace;

                // Generate the source code
                var source = GenerateLoggerSource(namespaceName, className, containingNamespace);
                var fileName = $"{namespaceName}_{className}_LoggerExtensions.g.cs";

                // Add the generated source
                context.AddSource(fileName, SourceText.From(source, Encoding.UTF8));
            }
        }

        private string GetNamespace(ClassDeclarationSyntax classDeclaration)
        {
            // Walk up the syntax tree to find the namespace
            var potentialNamespace = classDeclaration.Parent;
            while (potentialNamespace != null)
            {
                if (potentialNamespace is NamespaceDeclarationSyntax namespaceDeclaration)
                {
                    return namespaceDeclaration.Name.ToString();
                }
                potentialNamespace = potentialNamespace.Parent;
            }
            return string.Empty;
        }

        private string GenerateLoggerSource(string namespaceName, string className, INamespaceSymbol containingNamespace)
        {
            var namespaceDeclaration = string.IsNullOrEmpty(namespaceName)
                ? string.Empty
                : $"namespace {namespaceName}";

            var fullNamespace = containingNamespace.IsGlobalNamespace
                ? string.Empty
                : containingNamespace.ToDisplayString();

            return $@"
// <auto-generated/>
{namespaceDeclaration}
{{
    /// <summary>
    /// Partial class extension with auto-generated logger field.
    /// Logger field: _logger{className}
    /// </summary>
    public partial class {className}
    {{
        /// <summary>
        /// Gets the logger instance for this class.
        /// </summary>
        private static readonly Microsoft.Extensions.Logging.ILogger _logger{className} =
            Microsoft.Extensions.Logging.Abstractions.NullLogger.Instance;
    }}
}}
";
        }
    }

    /// <summary>
    /// Syntax receiver that collects candidate partial classes during syntax tree analysis.
    /// </summary>
    internal class SyntaxReceiver : ISyntaxReceiver
    {
        public List<ClassDeclarationSyntax> CandidateClasses { get; } = new();

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            // Look for partial class declarations
            if (syntaxNode is ClassDeclarationSyntax classDeclaration &&
                classDeclaration.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)))
            {
                CandidateClasses.Add(classDeclaration);
            }
        }
    }
}
